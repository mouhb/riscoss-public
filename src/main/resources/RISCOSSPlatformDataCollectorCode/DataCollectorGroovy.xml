<?xml version='1.0' encoding='UTF-8'?>
<xwikidoc version="1.1">
  <web>RISCOSSPlatformDataCollectorCode</web>
  <name>DataCollectorGroovy</name>
  <language/>
  <defaultLanguage/>
  <translation>0</translation>
  <creator>xwiki:XWiki.Admin</creator>
  <creationDate>1430839815000</creationDate>
  <parent>xwiki:XWiki.WebHome</parent>
  <author>xwiki:XWiki.superadmin</author>
  <contentAuthor>xwiki:XWiki.superadmin</contentAuthor>
  <date>1442962337000</date>
  <contentUpdateDate>1442962337000</contentUpdateDate>
  <version>1.66</version>
  <title/>
  <comment>Imported from XAR</comment>
  <minorEdit>true</minorEdit>
  <syntaxId>xwiki/2.1</syntaxId>
  <hidden>false</hidden>
  <content>/* -*- Mode:Java&#xd;
 * Groovy code for data collectors.&#xd;
 */&#xd;
import java.io.File;&#xd;
import org.json.JSONObject;&#xd;
import org.json.JSONArray;&#xd;
import java.util.ArrayList;&#xd;
import java.util.Arrays;&#xd;
import java.util.HashMap;&#xd;
import org.json.JSONObject;&#xd;
import java.util.concurrent.atomic.AtomicInteger;&#xd;
import org.apache.commons.io.IOUtils;&#xd;
import org.apache.http.impl.client.HttpClientBuilder;&#xd;
import org.apache.http.client.HttpClient;&#xd;
import org.apache.http.HttpResponse;&#xd;
import org.apache.http.client.methods.HttpPost;&#xd;
import org.apache.http.entity.StringEntity;&#xd;
import org.xwiki.environment.Environment;&#xd;
import org.apache.commons.codec.net.URLCodec;&#xd;
&#xd;
public class Ctx {&#xd;
&#xd;
    static final int COLLECTOR_TIMEOUT_MILLISECONDS = 600000;&#xd;
&#xd;
    final Object xwiki;&#xd;
    final Object services;&#xd;
    final Object xcontext;&#xd;
    String maybeRDRInfo;&#xd;
    final HashMap&lt;String, Long> millisecondsByPeriod;&#xd;
&#xd;
    Ctx(Object xwiki, Object services, Object xcontext, HashMap millisecondsByPeriod) {&#xd;
        this.xwiki = xwiki;&#xd;
        this.services = services;&#xd;
        this.xcontext = xcontext;&#xd;
        this.millisecondsByPeriod = millisecondsByPeriod;&#xd;
    }&#xd;
}&#xd;
&#xd;
private Ctx mkCtx(Object xwiki, Object services, Object xcontext)&#xd;
{&#xd;
    return new Ctx(xwiki, services, xcontext,&#xd;
        new HashMap&lt;String, Long>() {{&#xd;
            put("minutely", Long.valueOf(1000L * 60));&#xd;
            put("hourly",   Long.valueOf(1000L * 60 * 60));&#xd;
            put("daily",    Long.valueOf(1000L * 60 * 60 * 24));&#xd;
            put("weekly",   Long.valueOf(1000L * 60 * 60 * 24 * 7));&#xd;
            put("monthly",  Long.valueOf(1000L * 60 * 60 * 24 * 30));&#xd;
        }});&#xd;
}&#xd;
&#xd;
private Object getValue(Object obj, String name) {&#xd;
    def prop = obj.getProperty(name);&#xd;
    if (!prop) { return null; }&#xd;
    return prop.getValue();&#xd;
}&#xd;
&#xd;
private String getRDRInfo(Ctx ctx) {&#xd;
    if (ctx.maybeRDRInfo == null) {&#xd;
        def confDoc = ctx.xwiki.getDocument("RISCOSSPlatformCode.RISCOSSConfiguration");&#xd;
        def conf = confDoc.getObject("RISCOSSPlatformCode.RISCOSSConfiguration");&#xd;
        ctx.maybeRDRInfo = conf.getProperty("rdr").getValue();&#xd;
    }&#xd;
    return ctx.maybeRDRInfo;&#xd;
}&#xd;
&#xd;
public class CmdReturn {&#xd;
    String stdout = "";&#xd;
    String stderr = "";&#xd;
&#xd;
    static final int retcode_TIMEOUT = (1&lt;&lt;31);&#xd;
    int retcode;&#xd;
}&#xd;
&#xd;
private CmdReturn runCmd(Ctx ctx, String cmd, String stdin, Object wrkdir)&#xd;
{&#xd;
    System.out.println("debug: " + cmd + " &lt; " + stdin);&#xd;
&#xd;
    final CmdReturn out = new CmdReturn();&#xd;
    final AtomicInteger ai = new AtomicInteger(4);&#xd;
    final Process[] process = new Process[1];&#xd;
&#xd;
    new Thread(new Runnable() {public void run() {&#xd;
&#xd;
        process[0] =&#xd;
            new ProcessBuilder(Arrays.asList(cmd.split(" "))).directory(wrkdir).start();&#xd;
&#xd;
        new Thread(new Runnable() {public void run() {&#xd;
            out.stdout = IOUtils.toString(process[0].getInputStream(), "UTF-8");&#xd;
            ai.decrementAndGet();&#xd;
        } } ).start();&#xd;
        new Thread(new Runnable() {public void run() {&#xd;
            out.stderr = IOUtils.toString(process[0].getErrorStream(), "UTF-8");&#xd;
            ai.decrementAndGet();&#xd;
        } } ).start();&#xd;
        new Thread(new Runnable() {public void run() {&#xd;
            OutputStream stdinStream = process[0].getOutputStream();&#xd;
            IOUtils.write(stdin, stdinStream, "UTF-8");&#xd;
            stdinStream.close();&#xd;
            ai.decrementAndGet();&#xd;
        } } ).start();&#xd;
&#xd;
        process[0].waitFor();&#xd;
        out.retcode = process[0].exitValue();&#xd;
        ai.decrementAndGet();&#xd;
    }}).start();&#xd;
&#xd;
    int waitMilliseconds = 0;&#xd;
    while (ai.get() != 0) {&#xd;
        Thread.sleep(10);&#xd;
        waitMilliseconds += 10;&#xd;
        if (waitMilliseconds > Ctx.COLLECTOR_TIMEOUT_MILLISECONDS) {&#xd;
            if (process[0] != null) {&#xd;
                process[0].destroy();&#xd;
            }&#xd;
            System.out.println("warning: TIMEOUT " + cmd + " &lt; " + stdin);&#xd;
            out.retcode = CmdReturn.retcode_TIMEOUT;&#xd;
            return out;&#xd;
        }&#xd;
    }&#xd;
    return out;&#xd;
}&#xd;
&#xd;
// Copied from EvaluateGroovy, keep in sync, TODO: fix&#xd;
public File getAttachFile(Object services, Object xcontext, Object attachment)&#xd;
{&#xd;
    Object env = services.component.getInstance(Environment.class);&#xd;
    File tempDir = env.getTemporaryDirectory();&#xd;
    String encodedDocName = (new URLCodec()).encode(attachment.getDocument().getFullName());&#xd;
    File dir = new File(tempDir, "riscoss-" + encodedDocName);&#xd;
    String encodedFileName = (new URLCodec()).encode(attachment.getFilename());&#xd;
    File file = new File(dir, encodedFileName);&#xd;
    if (!dir.isDirectory()) {&#xd;
        if (!dir.mkdir()) { throw new RuntimeException("failed to make directory"); }&#xd;
    }&#xd;
    if (file.exists() &amp;&amp; file.length() != attachment.getFilesize()) {&#xd;
        file.delete();&#xd;
    }&#xd;
    if (!file.exists()) {&#xd;
        def input = attachment.getAttachment().getContentInputStream(xcontext.getContext());&#xd;
        Object output = new FileOutputStream(file);&#xd;
        IOUtils.copy(input, output);&#xd;
        IOUtils.closeQuietly(input);&#xd;
        IOUtils.closeQuietly(output);&#xd;
    }&#xd;
    if (!file.exists()) { throw new RuntimeException("[" + file + "] nonexistant"); }&#xd;
    if (file.length() != attachment.getFilesize()) {&#xd;
        throw new RuntimeException("[" + file + "] wrong length: expected: [" +&#xd;
            attachment.getFilesize() + "] got: [" + file.length() + "]");&#xd;
    }&#xd;
    return file;&#xd;
}&#xd;
// Copied from EvaluateGroovy, keep in sync, TODO: fix&#xd;
public File getAttachDir(Object services, Object xcontext, Object collectorDoc)&#xd;
{&#xd;
    File file = new File(System.getProperty("user.dir"));&#xd;
    for (def att : collectorDoc.getAttachmentList()) {&#xd;
        file = getAttachFile(services, xcontext, att).getParentFile()&#xd;
    }&#xd;
    return file;&#xd;
}&#xd;
&#xd;
private int uploadToRDR(String output, String rdrPath) throws Exception&#xd;
{&#xd;
    HttpClient client = HttpClientBuilder.create().build();&#xd;
    HttpPost request = new HttpPost(rdrPath);&#xd;
    request.setEntity(new StringEntity(output));&#xd;
    HttpResponse response = client.execute(request);&#xd;
    int responseCode = response.getStatusLine().getStatusCode();&#xd;
    System.out.println("Response Code : " + responseCode);&#xd;
    BufferedReader rd = new BufferedReader(&#xd;
      new InputStreamReader(response.getEntity().getContent()));&#xd;
    StringBuffer result = new StringBuffer();&#xd;
    String line = "";&#xd;
    while ((line = rd.readLine()) != null) {&#xd;
        System.err.println(line);&#xd;
    }&#xd;
    if (responseCode &lt; 200 || responseCode > 299) {&#xd;
        return responseCode;&#xd;
    }&#xd;
    return 0;&#xd;
}&#xd;
&#xd;
private List&lt;String> getRiskConfigurations(Ctx ctx, Object entityDoc)&#xd;
{&#xd;
    String sql =&#xd;
        "from doc.object(RISCOSSPlatformRiskConfigurationManagerCode.RiskConfigurationClass) " +&#xd;
        "as conf, doc.object(RISCOSSPlatformRiskConfigurationManagerCode.RiskModelClass) " +&#xd;
        "as model " +&#xd;
        "where doc.space = 'RISCOSSPlatformRiskConfigurations' and " +&#xd;
        "conf.autoEvaluate = 1 and model.layer = :layer";&#xd;
&#xd;
    def entity = entityDoc.getObject("RISCOSSPlatformLayerManagerCode.EntityClass");&#xd;
    String layer = getValue(entity, "layer");&#xd;
    return ctx.services.query.xwql(sql).bindValue("layer", layer).execute();&#xd;
}&#xd;
&#xd;
private boolean runEvals(Ctx ctx, Object entityDoc)&#xd;
{&#xd;
    boolean ok = true;&#xd;
    List&lt;String> configs = getRiskConfigurations(ctx, entityDoc);&#xd;
    if (configs.size() == 0) { return ok; }&#xd;
    def EVAL_GROOVY_PG = "RISCOSSPlatformRiskAnalysisManagerCode.EvaluateGroovy";&#xd;
    def analyserAPI = ctx.xwiki.parseGroovyFromPage(EVAL_GROOVY_PG);&#xd;
&#xd;
    for (String config : configs) {&#xd;
        def sessionDoc = analyserAPI.getSessionDoc(ctx.xwiki, entityDoc.getFullName(), config, true);&#xd;
        def inputs = analyserAPI.getInputs(ctx.services, ctx.xwiki, sessionDoc);&#xd;
System.out.println("xxx [" + inputs.getString("stdout") + "]");&#xd;
        def riskData = analyserAPI.getRiskData(ctx.services,&#xd;
                                               inputs,&#xd;
                                               analyserAPI.getRDRPath(ctx.xwiki),&#xd;
                                               entityDoc.getFullName());&#xd;
&#xd;
        def interpretedData = analyserAPI.interpret(ctx.xcontext, sessionDoc, riskData);&#xd;
        def out = analyserAPI.evaluate(ctx.services, ctx.xwiki, sessionDoc, interpretedData);&#xd;
        def output = out.optJSONObject("output");&#xd;
        def result = null;&#xd;
        if (output != null) { result = output.optJSONObject("result"); }&#xd;
        if (result == null) { ok = false; }&#xd;
        analyserAPI.storeResults(&#xd;
            sessionDoc, result, inputs, out, interpretedData, System.currentTimeMillis());&#xd;
        println(out.getJSONObject("output").getJSONObject("result"));&#xd;
    }&#xd;
    return ok;&#xd;
}&#xd;
&#xd;
private void runJob(Ctx ctx, Object entityDoc, Object collectorConf, Object scheduleConf) {&#xd;
    def collectorDoc = ctx.xwiki.getDocument(getValue(scheduleConf, "collectorName"));&#xd;
    def collectorObj = collectorDoc.getObject("RISCOSSPlatformDataCollectorCode.DataCollectorClass");&#xd;
    String command = getValue(collectorObj, "command");&#xd;
    String rdrPath = getRDRInfo(ctx);&#xd;
    def out = new JSONObject();&#xd;
    out.put("targetEntity", entityDoc.getName());&#xd;
    out.put("timeLastRun", getValue(scheduleConf, "timeLastRun"));&#xd;
    if (collectorConf != null) {&#xd;
        for (String propName : collectorConf.getxWikiClass().getEnabledPropertyNames()) {&#xd;
            String val = getValue(collectorConf, propName);&#xd;
            if (val != null &amp;&amp; !"".equals(val)) {&#xd;
                out.put(propName, val);&#xd;
            }&#xd;
        }&#xd;
    }&#xd;
    CmdReturn res = runCmd(&#xd;
        ctx, command, out.toString(), getAttachDir(ctx.services, ctx.xcontext, collectorDoc));&#xd;
    System.out.println("debug: stdout: " + res.stdout);&#xd;
    System.out.println("debug: stderr: " + res.stderr);&#xd;
    System.out.println("debug: retcode: " + res.retcode);&#xd;
    if (res.retcode != 0) { return; }&#xd;
    String stdout = res.stdout;&#xd;
    if (stdout.indexOf("-----BEGIN RISK DATA-----") != -1) {&#xd;
        stdout = stdout.substring(stdout.indexOf("-----BEGIN RISK DATA-----") +&#xd;
            "-----BEGIN RISK DATA-----".length());&#xd;
        stdout = stdout.substring(0, stdout.indexOf("-----END RISK DATA-----"));&#xd;
    }&#xd;
    if (!uploadToRDR(stdout, rdrPath) == 0) {&#xd;
        return;&#xd;
    /*} else if (!runEvals(ctx, entityDoc)) {  TODO: Make this work correctly.&#xd;
        return; */&#xd;
    } else {&#xd;
        rescheduleJob(ctx, entityDoc, scheduleConf);&#xd;
    }&#xd;
}&#xd;
&#xd;
private void rescheduleJob(Ctx ctx, Object doc, Object scheduleConf) {&#xd;
    if(scheduleConf){&#xd;
       scheduleConf.set("timeLastRun", System.currentTimeMillis());&#xd;
       doc.saveWithProgrammingRights("Ran DataCollector", true);&#xd;
    }&#xd;
}&#xd;
&#xd;
private void runSchedule(Ctx ctx, Object doc, Object scheduleConf) {&#xd;
    Long timeLastRun = getValue(scheduleConf, "timeLastRun");&#xd;
    if (timeLastRun == null) { timeLastRun = 0; }&#xd;
    String name = getValue(scheduleConf, "collectorName");&#xd;
    String fullName = doc.getFullName() + "/" + name;&#xd;
    Long milliseconds = ctx.millisecondsByPeriod.get(getValue(scheduleConf, "frequency"));&#xd;
    if (milliseconds == null) {&#xd;
        System.out.println("warning: [" + fullName + "] invalid frequency [" +&#xd;
            getValue(scheduleConf, "frequency") + "]");&#xd;
        return;&#xd;
    }&#xd;
    if (System.currentTimeMillis() - timeLastRun > milliseconds) {&#xd;
        Object collectorConf = doc.getObject(name);&#xd;
        if (scheduleConf == null) {&#xd;
            System.out.println("warning: [" + fullName + "] no object");&#xd;
            return;&#xd;
        }&#xd;
        try {&#xd;
            runJob(ctx, doc, collectorConf, scheduleConf);&#xd;
        } catch (Exception e) {&#xd;
            System.out.println("warning: error running [" + fullName + "]");&#xd;
            e.printStackTrace();&#xd;
        }&#xd;
    } else {&#xd;
        System.out.println("debug: [" + fullName + "] skipping because it is not time yet.");&#xd;
    }&#xd;
}&#xd;
&#xd;
/**&#xd;
*   Run the data collector on demand (without the scheduler)&#xd;
*/&#xd;
public void runDataCollectorOnDemand(Object xcontext, Object services, Object xwiki, entityDocRef){&#xd;
   Ctx ctx = mkCtx(xwiki, services, xcontext);&#xd;
   def entityDoc = ctx.xwiki.getDocument(entityDocRef);&#xd;
   def collectorDoc = ctx.xwiki.getDocument("RISCOSSPlatformRiskDataCollectors.GitHub");&#xd;
   def collectorObj = collectorDoc.getObject("RISCOSSPlatformDataCollectorCode.DataCollectorClass");&#xd;
   def scheduleConf = null;&#xd;
   String command = getValue(collectorObj, "command");&#xd;
   String rdrPath = getRDRInfo(ctx);&#xd;
   def out = new JSONObject();&#xd;
   out.put("targetEntity", entityDoc.getName());&#xd;
   CmdReturn res = runCmd(&#xd;
        ctx, command, out.toString(), getAttachDir(ctx.services, ctx.xcontext, collectorDoc));&#xd;
    System.out.println("debug: stdout: " + res.stdout);&#xd;
    System.out.println("debug: stderr: " + res.stderr);&#xd;
    System.out.println("debug: retcode: " + res.retcode);&#xd;
    if (res.retcode != 0) { return; }&#xd;
    String stdout = res.stdout;&#xd;
    if (stdout.indexOf("-----BEGIN RISK DATA-----") != -1) {&#xd;
        stdout = stdout.substring(stdout.indexOf("-----BEGIN RISK DATA-----") +&#xd;
            "-----BEGIN RISK DATA-----".length());&#xd;
        stdout = stdout.substring(0, stdout.indexOf("-----END RISK DATA-----"));&#xd;
    }&#xd;
    uploadToRDR(stdout, rdrPath);&#xd;
}&#xd;
&#xd;
private void runEntity(Ctx ctx, String docName) {&#xd;
&#xd;
    def doc = ctx.xwiki.getDocument(docName);&#xd;
    def scheduleConfs = doc.getObjects("RISCOSSPlatformDataCollectorCode.DataCollectorScheduler");&#xd;
    for (int i = 0; i &lt; scheduleConfs.size(); i++) {&#xd;
        runSchedule(ctx, doc, scheduleConfs.get(i));&#xd;
    }&#xd;
}&#xd;
&#xd;
public void main(Object xcontext, Object services, Object xwiki) {&#xd;
    Ctx ctx = mkCtx(xwiki, services, xcontext);&#xd;
    def docNames = ctx.services.query.xwql(&#xd;
            "from doc.object('RISCOSSPlatformDataCollectorCode.DataCollectorScheduler') as sched"&#xd;
        ).execute();&#xd;
    def dox = new ArrayList();&#xd;
    for (int i = 0; i &lt; docNames.size(); i++) {&#xd;
        runEntity(ctx, docNames.get(i));&#xd;
    }&#xd;
}&#xd;
</content>
</xwikidoc>